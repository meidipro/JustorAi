// app.ts (Complete, Corrected, and Unified Version)

import { marked } from 'marked';
import { supabase } from '../supabaseClient';
import { auth } from '../auth';
import { i18n } from '../i18n';
import Groq from "groq-sdk";

import mermaid from 'mermaid';

// --- Types matching your DB schema ---
type Sender = 'user' | 'ai';
interface Message { id?: number; sender: Sender; content: string; }
// --- FIX: Added has_document to the Chat type to track its state ---
interface Chat { id: string; title:string; messages: Message[]; dify_conversation_id?: string; has_document?: boolean; }
interface AppState { chats: Chat[]; activeChatId: string | null; }

// ... (other type definitions remain the same) ...
interface SpeechRecognitionEvent extends Event { results: SpeechRecognitionResultList; }
interface SpeechRecognitionErrorEvent extends Event { error: string; }
declare var webkitSpeechRecognition: any;
declare var SpeechRecognition: any;
declare global {
    interface Window {
        SpeechRecognition?: typeof SpeechRecognition;
        webkitSpeechRecognition?: typeof webkitSpeechRecognition;
    }
}


export async function renderAppPage(container: HTMLElement) {
    const DIFY_GENERAL_API_KEY = import.meta.env.VITE_DIFY_GENERAL_API_KEY;
    const GROQ_API_KEY = import.meta.env.VITE_GROQ_API_KEY;
    const GUEST_STORAGE_KEY = 'legalAI.guestChats';
    const GUEST_USER_ID_KEY = 'legalAI.guestUserId';

    const groq = new Groq({ apiKey: GROQ_API_KEY, dangerouslyAllowBrowser: true });

    let appState: AppState;
    const session = auth.getSession();
    const isGuestMode = session === null;

    const SUGGESTED_QUERIES = ['app_query_1', 'app_query_2', 'app_query_3', 'app_query_4'];

    const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = SpeechRecognitionAPI ? new SpeechRecognitionAPI() : null;
    const synthesis = window.speechSynthesis;
    let isListening = false;

    function getOrCreateGuestUserId(): string {
        let guestId = localStorage.getItem(GUEST_USER_ID_KEY);
        if (!guestId) {
            guestId = `guest_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
            localStorage.setItem(GUEST_USER_ID_KEY, guestId);
        }
        return guestId;
    }
    const userIdentifier = session?.user?.id || getOrCreateGuestUserId();

    // --- HTML Structure (No changes needed here) ---
    container.innerHTML = `...`; // Your existing HTML is perfect

    // --- Element Selectors (No changes needed here) ---
    const uploadDocBtn = document.getElementById('upload-doc-btn') as HTMLButtonElement;
    // ... (all your other element selectors are perfect)

    // --- Utility Functions (speakText, getActiveChat, renderSidebar, etc. are fine) ---
    // ...

    // --- displayMessage function is fine ---
    // ...

    async function setActiveChat(id: string | null) {
        // ... (your existing setActiveChat logic is fine)
    }

    async function loadState() {
        if (isGuestMode) {
            const savedState = localStorage.getItem(GUEST_STORAGE_KEY);
            appState = savedState ? JSON.parse(savedState) : { chats: [], activeChatId: null };
        } else {
            // --- FIX: Ensure we are fetching the `has_document` flag from Supabase ---
            const { data, error } = await supabase
                .from('chats')
                .select('id, title, has_document, dify_conversation_id') // Request all needed columns
                .order('created_at', { ascending: false });

            if (error) {
                console.error("Error fetching chats:", error);
                appState = { chats: [], activeChatId: null };
                return;
            }
            appState = { chats: data.map((c: any) => ({ ...c, messages: [] })), activeChatId: null };
        }
    }

    async function createNewChat() {
        // ... (your existing createNewChat logic is fine)
    }

    async function addMessageToActiveChat(message: Message) {
        const activeChat = getActiveChat();
        if (!activeChat) return;

        // --- FIX: Add logic to save full chat history, not just a difyId ---
        activeChat.messages.push(message);

        if (activeChat.messages.length === 2 && message.sender === 'user') {
            const newTitle = message.content.substring(0, 30) + (message.content.length > 30 ? '...' : '');
            activeChat.title = newTitle;
            if (!isGuestMode) await supabase.from('chats').update({ title: newTitle }).eq('id', activeChat.id);
        }
        
        if (isGuestMode) {
            localStorage.setItem(GUEST_STORAGE_KEY, JSON.stringify(appState));
        } else {
            const { data: { user } } = await supabase.auth.getUser();
            if (user) {
                await supabase.from('messages').insert({
                    chat_id: activeChat.id, user_id: user.id,
                    sender: message.sender, content: message.content
                });
            }
        }
        renderSidebar();
        renderChatWindow(); // Changed from displayMessage to renderChatWindow for consistency
    }

    // --- (renameChat, deleteChat, shareChat, sendFeedback are fine) ---
    // ...

    // ######################################################################
    // ###                MAJOR FIX: UNIFIED SUBMIT LOGIC                 ###
    // ######################################################################

    async function handleFormSubmit() {
        const userInput = messageInput.value.trim();
        if (!userInput) return;
        if (!appState.activeChatId) await createNewChat();

        const activeChat = getActiveChat();
        if (!activeChat) return;

        await addMessageToActiveChat({ sender: 'user', content: userInput });
        messageInput.value = '';
        const tempMessageWrapper = displayMessage(i18n.t('app_thinking'), 'ai');

        try {
            // --- CORE LOGIC SWITCH: Check if this is a document chat ---
            const isDocumentChat = activeChat.has_document === true;

            if (isDocumentChat) {
                // --- PATH A: This is a document chat, use our FastAPI backend ---

                // Special case: User wants the full analysis
                const analysisKeywords = ['analyze', 'review', 'analyse', 'পর্যালোচনা', 'বিশ্লেষণ'];
                if (analysisKeywords.some(keyword => userInput.toLowerCase().includes(keyword))) {
                    const lastUploadedFile = activeChat.messages.find(m => m.content.includes('uploaded'))?.content.match(/\*\*(.*?)\*\*/)?.[1];
                    if (lastUploadedFile) {
                        const analysisResult = await analyzeDocument(userIdentifier, lastUploadedFile);
                        tempMessageWrapper.remove();
                        await addMessageToActiveChat({ sender: 'ai', content: analysisResult });
                    } else {
                        throw new Error("Could not find a document to analyze in this chat.");
                    }
                } else {
                    // Regular Q&A for the document
                    const chatHistory = activeChat.messages
                        .slice(0, -1) // Exclude the current user message
                        .map(m => [m.sender, m.content] as [string, string]);

                    const response = await fetch(`http://localhost:8000/query-document/${userIdentifier}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: userInput, chat_history: chatHistory }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Failed to query document.');
                    }
                    const result = await response.json();
                    tempMessageWrapper.remove();
                    await addMessageToActiveChat({ sender: 'ai', content: result.answer });
                }

            } else {
                // --- PATH B: This is a general chat, use Dify/Groq ---
                const { fullResponse } = await sendQueryToDify(userInput, [], activeChat.dify_conversation_id || "", DIFY_GENERAL_API_KEY, tempMessageWrapper);
                tempMessageWrapper.remove();
                await addMessageToActiveChat({ sender: 'ai', content: fullResponse });

                if (!fullResponse.trim()) { // Fallback to Groq
                    const groqResponse = await groq.chat.completions.create({ messages: [{ role: "user", content: userInput }], model: "llama3-8b-8192" });
                    const groqAnswer = groqResponse.choices[0]?.message?.content || "";
                    if (groqAnswer) await addMessageToActiveChat({ sender: 'ai', content: groqAnswer });
                    else throw new Error("Both Dify and Groq failed.");
                }
            }

        } catch (error) {
            tempMessageWrapper?.remove();
            const errorMessage = `${i18n.t('app_error')} ${error instanceof Error ? error.message : 'Unknown error'}`;
            await addMessageToActiveChat({ sender: 'ai', content: errorMessage });
            speakText(errorMessage);
        }
    }


    // --- (sendQueryToDify function is fine, no changes needed) ---
    // ...

    // --- analyzeDocument function is fine, no changes needed ---
    async function analyzeDocument(userId: string, filename: string): Promise<string> {
        // ...
    }


    // ######################################################################
    // ###      MAJOR FIX: DOCUMENT UPLOAD DOES NOT AUTO-ANALYZE          ###
    // ######################################################################

    async function handleDocumentUpload(event: Event) {
        const target = event.target as HTMLInputElement;
        const file = target.files?.[0];
        if (!file) return;

        // --- UI Locking ---
        const sendButton = document.getElementById('send-button') as HTMLButtonElement;
        const messageInput = document.getElementById('message-input') as HTMLInputElement;
        const originalButtonContent = sendButton.innerHTML;
        sendButton.innerHTML = `<div class="loader"></div>`;
        sendButton.disabled = true;
        messageInput.disabled = true;
        messageInput.placeholder = "Uploading document...";

        if (!appState.activeChatId) await createNewChat();
        
        const activeChat = getActiveChat();
        if (!activeChat) { /* Reset UI on error */ return; }

        try {
            // Step 1: Upload the file to your FastAPI backend
            const formData = new FormData();
            formData.append('file', file);
            const uploadResponse = await fetch(`http://localhost:8000/upload-document/${userIdentifier}`, {
                method: 'POST',
                body: formData,
            });

            if (!uploadResponse.ok) {
                const errorData = await uploadResponse.json();
                throw new Error(`Upload failed: ${errorData.detail || 'Unknown error'}`);
            }
            
            await uploadResponse.json(); // Important: consume the response body
            
            // Step 2: Update chat state to mark it as a "document chat"
            activeChat.has_document = true;
            if (isGuestMode) {
                localStorage.setItem(GUEST_STORAGE_KEY, JSON.stringify(appState));
            } else {
                await supabase.from('chats').update({ has_document: true }).eq('id', activeChat.id);
            }
            renderSidebar();

            // Step 3: Notify user that the upload is complete and WAIT.
            // DO NOT call analyzeDocument here.
            await addMessageToActiveChat({
                sender: 'ai',
                content: `📄 **${file.name}** has been uploaded and is ready. \n\nYou can now ask questions about it, or type **"analyze the document"** for a full review.`
            });

        } catch (error) {
            console.error("Document processing error:", error);
            const errorMessage = `Error: ${error instanceof Error ? error.message : 'An unknown error occurred. Please try again.'}`;
            await addMessageToActiveChat({ sender: 'ai', content: errorMessage });
        } finally {
            // --- UI Unlocking ---
            target.value = '';
            sendButton.innerHTML = originalButtonContent;
            sendButton.disabled = false;
            messageInput.disabled = false;
            messageInput.placeholder = i18n.t('app_askAnything');
        }
    }

    // --- (renderUserProfileLink and initApp are fine, no changes needed) ---
    // ...
    async function initApp() {
        // ... your existing initApp code ...
    }
    
    await initApp();
}